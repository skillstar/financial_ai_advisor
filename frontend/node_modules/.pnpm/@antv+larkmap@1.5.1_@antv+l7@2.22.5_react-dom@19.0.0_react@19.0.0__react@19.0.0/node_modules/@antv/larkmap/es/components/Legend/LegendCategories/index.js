function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import React from 'react';
import classnames from 'classnames';
import { getGradientColors } from "../../../utils/color";
import "./index.css";
export var CLS_PREFIX = 'larkmap-legend-category';
export function LegendCategories(props) {
  var labels = props.labels,
    colors = props.colors,
    _props$geometryType = props.geometryType,
    geometryType = _props$geometryType === void 0 ? 'circle' : _props$geometryType,
    _props$isStrokeColor = props.isStrokeColor,
    isStrokeColor = _props$isStrokeColor === void 0 ? false : _props$isStrokeColor,
    style = props.style,
    cls_name = props.className;
  function getColor(item) {
    return isStrokeColor ? {
      border: "2px solid ".concat(item)
    } : {
      background: item
    };
  }
  function Conent(color) {
    return /*#__PURE__*/React.createElement("div", {
      className: classnames(CLS_PREFIX, cls_name),
      style: style
    }, labels.map(function (item, index) {
      return /*#__PURE__*/React.createElement("div", {
        className: "".concat(CLS_PREFIX, "__content"),
        key: "".concat(item, "__").concat(color[index], "__").concat(index)
      }, /*#__PURE__*/React.createElement("div", {
        className: classnames("".concat(CLS_PREFIX, "__content__shape"), _defineProperty({}, "".concat(CLS_PREFIX, "__content__").concat(geometryType), geometryType)),
        style: getColor(color[index])
      }), /*#__PURE__*/React.createElement("div", {
        className: "".concat(CLS_PREFIX, "labels")
      }, item));
    }));
  }
  function Renders() {
    if (Array.isArray(colors)) {
      return Conent(colors);
    }
    var colorGradient = getGradientColors(colors.startColor, colors.endColor, labels.length);
    return Conent(colorGradient);
  }
  return /*#__PURE__*/React.createElement(Renders, null);
}