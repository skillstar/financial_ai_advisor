import { ScaleTypes } from '@antv/l7';
import { Log } from '@antv/scale';
export const DefaultScaleType = ScaleTypes.LINEAR;
export function getSizeAttribute(sizeAttr, weightRange) {
    var _a;
    if (sizeAttr instanceof Object && !(sizeAttr instanceof Function) && !Array.isArray(sizeAttr)) {
        const { field, value } = sizeAttr;
        if (field === 'weight' && Array.isArray(value) && value.length) {
            const scaleType = (((_a = sizeAttr.scale) === null || _a === void 0 ? void 0 : _a.type) || DefaultScaleType);
            return Object.assign(Object.assign({}, sizeAttr), { scale: {
                    field: 'size',
                    type: scaleType,
                    domain: weightRange,
                } });
        }
    }
    return sizeAttr;
}
export function getColorAttribute(colorAttr, weightRange) {
    var _a;
    if (colorAttr instanceof Object && !(colorAttr instanceof Function) && !Array.isArray(colorAttr)) {
        const { field, value } = colorAttr;
        if (field === 'weight' && Array.isArray(value) && value.length) {
            const scaleType = (((_a = colorAttr.scale) === null || _a === void 0 ? void 0 : _a.type) || DefaultScaleType);
            return Object.assign(Object.assign({}, colorAttr), { scale: {
                    field: 'color',
                    type: scaleType,
                    domain: weightRange,
                } });
        }
    }
    return colorAttr;
}
export function getOpacityColorAttribute(weightRange, fadeOpacityAmount) {
    const scaleFunc = new Log({
        domain: weightRange,
        range: [0, 1],
    });
    const ratio = (1 - fadeOpacityAmount / 100) * 1.5;
    return {
        field: 'weight',
        value: (weight) => {
            return scaleFunc.map(weight) * ratio;
        },
    };
}
export function getLineOffsetsAttribute(clusterIndex, circleLayer) {
    var _a;
    const circleLayerSizeAttribute = circleLayer.options.size;
    if (typeof circleLayerSizeAttribute === 'number') {
        return [circleLayerSizeAttribute, circleLayerSizeAttribute];
    }
    else {
        const sizeScale = (_a = circleLayer === null || circleLayer === void 0 ? void 0 : circleLayer.layer) === null || _a === void 0 ? void 0 : _a.getScale('size');
        return {
            field: 'fromId*toId',
            value: (fromId, toId) => {
                var _a, _b;
                const fromCluster = clusterIndex.clusterIdMap.get(fromId);
                const toCluster = clusterIndex.clusterIdMap.get(toId);
                const fromOffset = (_a = (fromCluster ? sizeScale === null || sizeScale === void 0 ? void 0 : sizeScale(fromCluster.weight) : 0)) !== null && _a !== void 0 ? _a : 0;
                const toOffset = (_b = (toCluster ? sizeScale === null || sizeScale === void 0 ? void 0 : sizeScale(toCluster.weight) : 0)) !== null && _b !== void 0 ? _b : 0;
                return [fromOffset, toOffset];
            },
        };
    }
}
//# sourceMappingURL=style.js.map