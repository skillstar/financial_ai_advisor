import { __rest } from "tslib";
import { clone, isEqual, isUndefined, omit } from '@antv/util';
import { CompositeLayer } from '../../core/composite-layer';
import { PointLayer } from '../../core-layers/point-layer';
import { TextLayer } from '../../core-layers/text-layer';
import { getDefaultState } from './adaptor';
import { EMPTY_JSON_SOURCE } from '../common/constants';
import { DEFAULT_OPTIONS, DEFAULT_STATE } from './constants';
import { getLabelLayerOptions } from '../common/label-layer';
import { isGestureMultiSelect } from '../common/multi-select';
export class BubbleLayer extends CompositeLayer {
    /**
     * 主图层
     */
    get layer() {
        return this.fillLayer;
    }
    /**
     * 填充图层
     */
    get fillLayer() {
        return this.subLayers.getLayer('fillLayer');
    }
    /**
     * 高亮描边图层
     */
    get highlightStrokeLayer() {
        return this.subLayers.getLayer('highlightStrokeLayer');
    }
    /**
     * 选中填充面图层
     */
    get selectFillLayer() {
        return this.subLayers.getLayer('selectFillLayer');
    }
    /**
     * 选中描边图层
     */
    get selectStrokeLayer() {
        return this.subLayers.getLayer('selectStrokeLayer');
    }
    /**
     * 标注文本图层
     */
    get labelLayer() {
        return this.subLayers.getLayer('labelLayer');
    }
    constructor(options) {
        super(options);
        /**
         * 复合图层类型
         */
        this.type = CompositeLayer.LayerType.BubbleLayer;
        /**
         * 选中数据
         */
        this.selectData = [];
        /**
         * 图层交互状态配置
         */
        this.layerState = DEFAULT_STATE;
        /**
         * 图层高亮回调
         */
        this.onHighlighHandle = (event) => {
            const { feature, featureId } = event;
            this.setHighlightLayerSource(feature, featureId);
        };
        /**
         * 图层取消高亮回调
         */
        this.onUnhighlighHandle = () => {
            this.setHighlightLayerSource();
        };
        /**
         * 图层选中回调
         */
        this.onSelectHandle = (event) => {
            const { feature, featureId } = event;
            this.handleSelectData(featureId, feature);
        };
        this.initSubLayersEvent();
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return BubbleLayer.DefaultOptions;
    }
    /**
     * 创建子图层
     */
    createSubLayers() {
        const source = this.source;
        this.layerState = getDefaultState(this.options.state);
        // 映射填充图层
        const fillLayer = new PointLayer(Object.assign(Object.assign({}, this.getFillLayerOptions()), { id: 'fillLayer', shape: 'circle', source, interaction: true }));
        // 高亮描边图层
        const highlightStrokeLayer = new PointLayer(Object.assign(Object.assign({}, this.getHighlightStrokeLayerOptions()), { id: 'highlightStrokeLayer', shape: 'circle' }));
        // 选中填充图层
        const selectFillLayer = new PointLayer(Object.assign(Object.assign({}, this.getSelectFillLayerOptions()), { id: 'selectFillLayer', shape: 'circle' }));
        // 选中描边图层
        const selectStrokeLayer = new PointLayer(Object.assign(Object.assign({}, this.getSelectStrokeLayerOptions()), { id: 'selectStrokeLayer', shape: 'circle' }));
        // 标注图层
        const labelLayer = new TextLayer(Object.assign(Object.assign({}, getLabelLayerOptions(this.options)), { id: 'labelLayer', source }));
        const subLayers = [fillLayer, highlightStrokeLayer, selectFillLayer, selectStrokeLayer, labelLayer];
        return subLayers;
    }
    /**
     * 获取填充图层配置项
     */
    getFillLayerOptions() {
        const _a = omit(this.options, ['source']), { visible, minZoom, maxZoom, zIndex = 0, fillColor, radius, opacity, strokeColor, lineOpacity, lineWidth } = _a, baseConfig = __rest(_a, ["visible", "minZoom", "maxZoom", "zIndex", "fillColor", "radius", "opacity", "strokeColor", "lineOpacity", "lineWidth"]);
        // omit source 目前是图层共享 source，避免更新时透传 source 数据
        const defaultState = this.layerState;
        const fillState = {
            active: defaultState.active.fillColor === false ? false : { color: defaultState.active.fillColor },
            select: false,
        };
        const fillStyle = {
            opacity: opacity,
            stroke: strokeColor,
            strokeOpacity: isUndefined(lineOpacity) ? opacity : lineOpacity,
            strokeWidth: lineWidth,
        };
        const options = Object.assign(Object.assign({}, baseConfig), { visible,
            minZoom,
            maxZoom,
            zIndex, color: fillColor, size: radius, state: fillState, style: fillStyle });
        return options;
    }
    getHighlightStrokeLayerOptions() {
        var _a;
        const { visible, minZoom, maxZoom, zIndex = 0, radius } = this.options;
        const defaultState = this.layerState;
        const strokeStyle = {
            opacity: 0,
            stroke: defaultState.active.strokeColor || undefined,
            strokeOpacity: defaultState.active.lineOpacity,
            strokeWidth: (_a = defaultState.active) === null || _a === void 0 ? void 0 : _a.lineWidth,
        };
        const options = {
            visible: visible && Boolean(defaultState.active.strokeColor),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: EMPTY_JSON_SOURCE,
            size: radius,
            style: strokeStyle,
        };
        return options;
    }
    getSelectFillLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, radius, opacity } = this.options;
        const defaultState = this.layerState;
        const color = defaultState.select.fillColor || undefined;
        const fillStyle = { opacity: opacity };
        const option = {
            visible: visible && Boolean(color),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: EMPTY_JSON_SOURCE,
            color,
            size: radius,
            style: fillStyle,
            state: { select: false, active: false },
        };
        return option;
    }
    getSelectStrokeLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, radius } = this.options;
        const defaultState = this.layerState;
        const strokeStyle = {
            opacity: 0,
            stroke: defaultState.select.strokeColor || undefined,
            strokeOpacity: defaultState.select.lineOpacity,
            strokeWidth: defaultState.select.lineWidth,
        };
        const option = {
            visible: visible && Boolean(strokeStyle.stroke),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: EMPTY_JSON_SOURCE,
            size: radius,
            style: strokeStyle,
        };
        return option;
    }
    /**
     * 设置子图层数据
     */
    setSubLayersSource(source) {
        if (this.isSourceInstance(source)) {
            this.source = source;
            this.fillLayer.setSource(source);
            this.labelLayer.setSource(source);
        }
        else {
            const { data } = source, option = __rest(source, ["data"]);
            this.source.setData(data, option);
        }
        this.highlightStrokeLayer.changeData(EMPTY_JSON_SOURCE);
        this.selectFillLayer.changeData(EMPTY_JSON_SOURCE);
        this.selectStrokeLayer.changeData(EMPTY_JSON_SOURCE);
    }
    /**
     * 设置高亮描边子图层数据
     */
    setHighlightLayerSource(feature, featureId = -999) {
        if (this.highlightData === featureId) {
            return;
        }
        const features = feature ? [feature] : [];
        const parser = this.source.parser;
        const data = parser.type === 'geojson' ? { type: 'FeatureCollection', features } : features;
        if (features.length) {
            // 获取映射后的 size 大小，避免 fillLayer 的 size 不是常量的情况
            const encodedData = this.fillLayer.layer.getEncodedData();
            const encodedFeature = encodedData.find((item) => item.id === featureId);
            const featureSize = encodedFeature === null || encodedFeature === void 0 ? void 0 : encodedFeature.size;
            this.highlightStrokeLayer.update({ size: featureSize, source: { data, parser } });
        }
        else {
            this.highlightStrokeLayer.changeData({ data, parser });
        }
        this.highlightData = featureId;
    }
    /**
     * 设置选中描边与填充子图层数据
     */
    setSelectLayerSource(selectData = []) {
        if (this.selectData.length === selectData.length &&
            isEqual(this.selectData.map(({ featureId }) => featureId), selectData.map(({ featureId }) => featureId))) {
            return;
        }
        const parser = this.source.parser;
        if (selectData.length) {
            const featureSizeKey = '_Feature_Size_';
            // 获取映射后的 size 大小，避免 fillLayer 的 size 不是常量的情况
            const encodedData = this.fillLayer.layer.getEncodedData();
            let data;
            if (parser.type === 'geojson') {
                data = {
                    type: 'FeatureCollection',
                    features: selectData.map(({ feature, featureId }) => {
                        var _a;
                        return (Object.assign(Object.assign({}, feature), { properties: Object.assign(Object.assign({}, feature.properties), { [featureSizeKey]: (_a = encodedData.find((item) => item.id === featureId)) === null || _a === void 0 ? void 0 : _a.size }) }));
                    }),
                };
            }
            else {
                data = selectData.map(({ feature, featureId }) => {
                    var _a;
                    return (Object.assign(Object.assign({}, feature), { [featureSizeKey]: (_a = encodedData.find((item) => item.id === featureId)) === null || _a === void 0 ? void 0 : _a.size }));
                });
            }
            const sizeAttr = {
                field: featureSizeKey,
                value: (obj) => obj[featureSizeKey],
            };
            this.selectFillLayer.update({
                size: sizeAttr,
                source: { data, parser },
            });
            this.selectStrokeLayer.update({
                size: sizeAttr,
                source: { data, parser },
            });
        }
        else {
            const data = parser.type === 'geojson' ? { type: 'FeatureCollection', features: [] } : [];
            this.selectFillLayer.changeData({ data, parser });
            this.selectStrokeLayer.changeData({ data, parser });
        }
        this.selectData = selectData;
    }
    /**
     * 初始化子图层事件
     */
    initSubLayersEvent() {
        // 初始化主图层交互事件
        this.fillLayer.off('mousemove', this.onHighlighHandle);
        this.fillLayer.off('mouseout', this.onHighlighHandle);
        this.fillLayer.off('click', this.onSelectHandle);
        this.selectData = [];
        this.highlightData = null;
        if (!this.options.state)
            return;
        // active
        if (this.options.state.active) {
            this.fillLayer.on('mousemove', this.onHighlighHandle);
            this.fillLayer.on('mouseout', this.onUnhighlighHandle);
        }
        // select
        if (this.options.state.select) {
            this.fillLayer.on('click', this.onSelectHandle);
        }
    }
    handleSelectData(featureId, feature, isSelfMultiSelect) {
        const { enabledMultiSelect, triggerMultiSelectKey } = this.options;
        const isMultiSelect = isGestureMultiSelect(enabledMultiSelect, triggerMultiSelectKey) || isSelfMultiSelect;
        let selectData = clone(this.selectData);
        const index = selectData.findIndex((item) => item.featureId === featureId);
        if (index === -1) {
            if (isMultiSelect) {
                selectData.push({ feature, featureId });
            }
            else {
                selectData = [{ feature, featureId }];
            }
            this.emit('select', feature, clone(selectData));
        }
        else {
            const unselectFeature = selectData[index];
            if (isMultiSelect) {
                selectData.splice(index, 1);
            }
            else {
                selectData = [];
            }
            this.emit('unselect', unselectFeature, clone(selectData));
        }
        this.setSelectLayerSource(selectData);
    }
    /**
     * 更新
     */
    update(options) {
        super.update(options);
        this.initSubLayersEvent();
    }
    /**
     * 更新: 更新配置
     */
    updateOption(options) {
        super.updateOption(options);
        this.layerState = getDefaultState(this.options.state);
    }
    /**
     * 更新子图层
     */
    updateSubLayers(options) {
        // 映射填充面图层
        this.fillLayer.update(this.getFillLayerOptions(), false);
        // 高亮图层
        this.highlightStrokeLayer.update(this.getHighlightStrokeLayerOptions(), false);
        // 选中填充图层
        this.selectFillLayer.update(this.getSelectFillLayerOptions(), false);
        // 选中描边图层
        this.selectStrokeLayer.update(this.getSelectStrokeLayerOptions(), false);
        // 标注图层
        this.labelLayer.update(getLabelLayerOptions(this.options), false);
        // 重置高亮/选中状态
        if (this.options.visible) {
            if (!isUndefined(options.state) && !isEqual(this.lastOptions.state, this.options.state)) {
                this.updateHighlightSubLayers();
            }
            if (this.layerState.active.strokeColor) {
                this.setHighlightLayerSource();
            }
            if (this.layerState.select.fillColor || this.layerState.select.strokeColor) {
                this.setSelectLayerSource();
            }
        }
    }
    /**
     * 更新高亮及选中子图层
     */
    updateHighlightSubLayers() {
        const defaultState = this.layerState;
        const lasetDefaultState = getDefaultState(this.lastOptions.state);
        if (lasetDefaultState.active.strokeColor !== defaultState.active.strokeColor) {
            defaultState.active.strokeColor ? this.highlightStrokeLayer.show() : this.highlightStrokeLayer.hide();
        }
        if (lasetDefaultState.select.fillColor !== defaultState.select.fillColor) {
            defaultState.select.fillColor ? this.selectFillLayer.show() : this.selectFillLayer.hide();
        }
        if (lasetDefaultState.select.strokeColor !== defaultState.select.strokeColor) {
            defaultState.select.strokeColor ? this.selectStrokeLayer.show() : this.selectStrokeLayer.hide();
        }
    }
    /**
     * 设置图层 zIndex
     */
    setIndex(zIndex) {
        this.fillLayer.setIndex(zIndex);
        this.highlightStrokeLayer.setIndex(zIndex + 0.1);
        this.selectFillLayer.setIndex(zIndex + 0.1);
        this.selectStrokeLayer.setIndex(zIndex + 0.1);
        this.labelLayer.setIndex(zIndex + 0.1);
    }
    /**
     * 设置图层高亮状态
     */
    setActive(field, value) {
        const source = this.fillLayer.source;
        const featureId = source.getFeatureId(field, value);
        if (isUndefined(featureId)) {
            console.warn(`Feature non-existent by field: ${field},value: ${value}`);
            return;
        }
        if (this.layerState.active.fillColor) {
            this.fillLayer.layer.setActive(featureId);
        }
        if (this.layerState.active.strokeColor) {
            const feature = source.getFeatureById(featureId);
            this.setHighlightLayerSource(feature, featureId);
        }
    }
    /**
     * 设置图层选中状态
     */
    setSelect(field, value) {
        const source = this.fillLayer.source;
        const featureId = source.getFeatureId(field, value);
        if (isUndefined(featureId)) {
            console.warn(`Feature non-existent by field: ${field},value: ${value}`);
            return;
        }
        if (this.layerState.select.strokeColor === false && this.layerState.select.fillColor === false) {
            return;
        }
        const feature = source.getFeatureById(featureId);
        const { enabledMultiSelect } = this.options;
        this.handleSelectData(featureId, feature, enabledMultiSelect);
    }
    /**
     * 图层框选数据
     */
    boxSelect(bounds, callback) {
        this.fillLayer.boxSelect(bounds, callback);
    }
}
/**
 * 默认配置项
 */
BubbleLayer.DefaultOptions = DEFAULT_OPTIONS;
//# sourceMappingURL=index.js.map