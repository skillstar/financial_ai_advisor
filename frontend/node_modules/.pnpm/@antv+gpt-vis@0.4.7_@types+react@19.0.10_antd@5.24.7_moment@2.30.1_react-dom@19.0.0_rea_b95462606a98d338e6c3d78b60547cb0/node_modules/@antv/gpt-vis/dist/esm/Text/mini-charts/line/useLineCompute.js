import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { useEffect, useState } from 'react';
import { TEXT_THEME } from "../../theme";
import { scaleLinear } from "./scaleLinear";

// adjust to draw line width
var SCALE_ADJUST = 2;
var Line = /*#__PURE__*/function () {
  function Line(size, data) {
    _classCallCheck(this, Line);
    _defineProperty(this, "data", []);
    _defineProperty(this, "size", TEXT_THEME.fontSizeBase);
    _defineProperty(this, "height", this.size);
    _defineProperty(this, "width", this.getWidth());
    _defineProperty(this, "xScale", void 0);
    _defineProperty(this, "yScale", void 0);
    _defineProperty(this, "points", []);
    this.size = size;
    if (data) {
      this.data = data;
      this.compute();
    }
  }
  _createClass(Line, [{
    key: "getWidth",
    value: function getWidth() {
      var _this$data;
      return Math.max(this.size * 2, ((_this$data = this.data) === null || _this$data === void 0 ? void 0 : _this$data.length) * 2);
    }
  }, {
    key: "compute",
    value: function compute() {
      var _this$data2,
        _this = this;
      if (!this.data) return;
      this.height = this.size;
      this.width = this.getWidth();
      this.xScale = scaleLinear([0, this.width], [0, ((_this$data2 = this.data) === null || _this$data2 === void 0 ? void 0 : _this$data2.length) - 1]);
      var _ref = [Math.min.apply(Math, _toConsumableArray(this.data)), Math.max.apply(Math, _toConsumableArray(this.data))],
        min = _ref[0],
        max = _ref[1];
      this.yScale = scaleLinear([SCALE_ADJUST, this.height - SCALE_ADJUST], [min, max]);
      this.points = this.data.map(function (item, index) {
        return [_this.xScale(index), _this.height - _this.yScale(item)];
      });
    }
  }, {
    key: "getLinePath",
    value: function getLinePath() {
      var _this$data3;
      if (!((_this$data3 = this.data) !== null && _this$data3 !== void 0 && _this$data3.length) || !this.xScale || !this.yScale) return null;
      var path = this.points.reduce(function (prev, _ref2, index) {
        var _ref3 = _slicedToArray(_ref2, 2),
          x = _ref3[0],
          y = _ref3[1];
        if (index === 0) return "M".concat(x, " ").concat(y);
        return "".concat(prev, " L ").concat(x, " ").concat(y);
      }, '');
      return path;
    }
  }, {
    key: "getPolygonPath",
    value: function getPolygonPath() {
      var _this$data4;
      if (!((_this$data4 = this.data) !== null && _this$data4 !== void 0 && _this$data4.length) || !this.xScale || !this.yScale) return null;
      var polygonPoints = _toConsumableArray(this.points);
      var last = this.points[this.points.length - 1];
      polygonPoints.push([last[0], this.height]);
      polygonPoints.push([0, this.height]);
      var startPoint = this.points[0];
      polygonPoints.push(startPoint);
      var path = polygonPoints.reduce(function (prev, _ref4) {
        var _ref5 = _slicedToArray(_ref4, 2),
          x = _ref5[0],
          y = _ref5[1];
        return "".concat(prev, " ").concat(x, ",").concat(y);
      }, '');
      return path;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return [this.width, this.height];
    }
  }]);
  return Line;
}();
export var useLineCompute = function useLineCompute(size, data) {
  var _useState = useState(new Line(size, data)),
    _useState2 = _slicedToArray(_useState, 2),
    line = _useState2[0],
    setLine = _useState2[1];
  useEffect(function () {
    setLine(new Line(size, data));
  }, [size, data]);
  return {
    width: line.getContainer()[0],
    height: line.getContainer()[1],
    linePath: line.getLinePath(),
    polygonPath: line.getPolygonPath()
  };
};