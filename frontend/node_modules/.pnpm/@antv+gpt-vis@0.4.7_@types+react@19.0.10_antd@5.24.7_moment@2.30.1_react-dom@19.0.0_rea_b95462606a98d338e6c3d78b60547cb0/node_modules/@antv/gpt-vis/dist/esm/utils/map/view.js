function fitIncludePoints(includePoints, scene, includePadding) {
  if (includePoints.length === 1) {
    scene.setCenter([includePoints[0].longitude, includePoints[0].latitude]);
  } else {
    var bounds = [180, 90, -180, -90];
    includePoints.forEach(function (point) {
      if (bounds[0] > point.longitude) {
        bounds[0] = point.longitude;
      }
      if (bounds[1] > point.latitude) {
        bounds[1] = point.latitude;
      }
      if (bounds[2] < point.longitude) {
        bounds[2] = point.longitude;
      }
      if (bounds[3] < point.latitude) {
        bounds[3] = point.latitude;
      }
    });
    var _ref = includePadding || {},
      _ref$left = _ref.left,
      left = _ref$left === void 0 ? 20 : _ref$left,
      _ref$right = _ref.right,
      right = _ref$right === void 0 ? 20 : _ref$right,
      _ref$bottom = _ref.bottom,
      bottom = _ref$bottom === void 0 ? 20 : _ref$bottom,
      _ref$top = _ref.top,
      top = _ref$top === void 0 ? 20 : _ref$top;
    var padding = [left, top, right, bottom];
    // @ts-ignore
    scene.map.setBounds(bounds, false, padding);
  }
}
export var setMapView = function setMapView(props, scene) {
  fitBounds(props, scene);
  setMapStatus(props, scene);
};
export var fitBounds = function fitBounds(props, scene) {
  var _props$includePoints;
  if ((_props$includePoints = props.includePoints) !== null && _props$includePoints !== void 0 && _props$includePoints.length) {
    fitIncludePoints(props.includePoints, scene, props.includePadding);
  } else {
    var points = [];
    if (props.markers) {
      props.markers.forEach(function (item) {
        points.push({
          longitude: item.longitude,
          latitude: item.latitude
        });
      });
    }
    if (props.polyline) {
      props.polyline.forEach(function (item) {
        item.points.forEach(function (point) {
          points.push({
            longitude: point.longitude,
            latitude: point.latitude
          });
        });
      });
    }
    if (points.length) {
      fitIncludePoints(points, scene, props.includePadding);
    }
  }
};
export var setMapStatus = function setMapStatus(props, scene) {
  if (props.enableZoom !== undefined) {
    scene.setMapStatus({
      zoomEnable: props.enableZoom
    });
  }
  if (props.enableRotate !== undefined) {
    scene.setMapStatus({
      rotateEnable: props.enableRotate
    });
  }
  if (props.enableScroll !== undefined) {
    scene.setMapStatus({
      dragEnable: props.enableScroll
    });
  }
};