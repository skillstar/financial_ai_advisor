"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataProvider = void 0;
const tslib_1 = require("tslib");
const event_emitter_1 = tslib_1.__importDefault(require("@antv/event-emitter"));
const reselect_1 = require("reselect");
const build_index_1 = require("./build-index");
const cluster_1 = require("./cluster");
const transform_1 = require("./transform");
class DataProvider extends event_emitter_1.default {
    constructor() {
        super(...arguments);
        this.getSourceData = (source, config) => source.data;
        this.getSourceParser = (source, config) => source.parser;
        this.getMapZoom = (source, config) => config.mapStatus.zoom;
        this.getMapBounds = (source, config) => config.mapStatus.bounds;
        this.getEnableCluster = (source, config) => config.enableCluster;
        this.getClusterType = (source, config) => config.clusterType;
        this.getExtent = (source, config) => config.clusterExtent;
        this.getNodeSize = (source, config) => config.clusterNodeSize;
        this.getRadius = (source, config) => config.clusterRadius;
        this.getMinZoom = (source, config) => config.minZoom;
        this.getMaxZoom = (source, config) => config.maxZoom;
        this.getZoomStep = (source, config) => config.clusterZoomStep;
        this.getMaxTopFlowNum = (source, config) => config.maxTopFlowNum;
        /**
         * 将 source 转换成最底层的客流点/线数据
         */
        this.getOriginData = (0, reselect_1.createSelector)(this.getSourceData, this.getSourceParser, (data, parser) => {
            return (0, transform_1.transformSource)({ data, parser });
        });
        /**
         * 获取聚合配置
         */
        this.getClusterOptions = (0, reselect_1.createSelector)(this.getClusterType, this.getEnableCluster, this.getExtent, this.getNodeSize, this.getRadius, this.getMinZoom, this.getMaxZoom, this.getZoomStep, function (clusterType, enableCluster, clusterExtent, clusterNodeSize, clusterRadius, minZoom, maxZoom, clusterZoomStep) {
            return {
                clusterType,
                enableCluster,
                clusterExtent,
                clusterNodeSize,
                clusterRadius,
                minZoom,
                maxZoom,
                clusterZoomStep,
            };
        });
        /**
         * 获取各个层级下的聚合点数组
         */
        this.getClusterLevels = (0, reselect_1.createSelector)(this.getOriginData, this.getClusterOptions, ({ locations }, clusterOptions) => {
            return (0, cluster_1.clusterLocations)(locations, clusterOptions);
        });
        /**
         * 获取聚合点的检索器
         */
        this.getClusterIndex = (0, reselect_1.createSelector)(this.getClusterLevels, (clusterLevels) => {
            return (0, build_index_1.buildIndex)(clusterLevels);
        });
        /**
         * 获取当前需要展示的聚合点
         */
        this.getViewLocations = (0, reselect_1.createSelector)(this.getClusterIndex, this.getMapZoom, this.getMapBounds, (clusterIndex, zoom, bounds) => {
            return clusterIndex.getMapLocations(zoom, bounds);
        });
        this.getLocationWeightRange = (0, reselect_1.createSelector)(this.getClusterIndex, this.getMapZoom, function (clusterIndex, zoom) {
            const { locations } = clusterIndex.getAppropriateLevel(zoom);
            if (!locations.length) {
                return [0, 0];
            }
            const { weight: minWeight } = locations[0];
            const { weight: maxWeight } = locations[locations.length - 1];
            return [minWeight, maxWeight];
        });
        /**
         * 获取当前层级下的聚合线数据
         */
        this.getAggregatedFlows = (0, reselect_1.createSelector)(this.getClusterIndex, this.getOriginData, this.getMapZoom, (clusterIndex, { flows: originFlows }, zoom) => {
            return (0, cluster_1.clusterFlows)(originFlows, clusterIndex, zoom);
        });
        /**
         * 获取当前需要展示的聚合线数据
         */
        this.getFilterFlows = (0, reselect_1.createSelector)(this.getViewLocations, this.getAggregatedFlows, this.getMaxTopFlowNum, (filterLocations, fullFlows, maxTopFlowNum) => {
            if (fullFlows.length <= maxTopFlowNum) {
                return fullFlows;
            }
            let flows = [...fullFlows];
            const filterLocationIdSet = new Set(filterLocations.map((location) => location.id));
            flows = flows.filter((flow) => {
                return filterLocationIdSet.has(flow.fromId) || filterLocationIdSet.has(flow.toId);
            });
            if (flows.length > maxTopFlowNum) {
                flows = flows.slice(flows.length - maxTopFlowNum, flows.length);
            }
            return flows;
        });
        this.getFilterLocations = (0, reselect_1.createSelector)(this.getViewLocations, this.getFilterFlows, (locations, flows) => {
            const locationIdSet = new Set(flows.map((flow) => [flow.fromId, flow.toId]).flat());
            return locations.filter((location) => locationIdSet.has(location.id));
        });
        /**
         * 获取当前层级下筛选前的权重区间，用于计算客流线的宽度和颜色深浅
         */
        this.getFlowWeightRange = (0, reselect_1.createSelector)(this.getAggregatedFlows, function (flows) {
            if (!flows.length) {
                return [0, 0];
            }
            const { weight: minWeight } = flows[0];
            const { weight: maxWeight } = flows[flows.length - 1];
            return [minWeight, maxWeight];
        });
        /**
         * 获取当前层级下筛选后的客流线的权重区间，主要用于客流线透明度的计算
         */
        this.getFilterFlowWeightRange = (0, reselect_1.createSelector)(this.getFilterFlows, function (flows) {
            if (!flows.length) {
                return [0, 0];
            }
            const { weight: minWeight } = flows[0];
            const { weight: maxWeight } = flows[flows.length - 1];
            return [minWeight, maxWeight];
        });
    }
}
exports.DataProvider = DataProvider;
//# sourceMappingURL=index.js.map