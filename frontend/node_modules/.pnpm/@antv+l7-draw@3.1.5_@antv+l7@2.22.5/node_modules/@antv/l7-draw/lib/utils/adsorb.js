"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPositionInBBox = exports.getPixelExpandBBox = exports.getAdsorbPosition = void 0;
var _mode = require("../mode");
var _turf = require("@turf/turf");
var _common = require("./common");
var _feature = require("./feature");
var _lodash = require("lodash");
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
var getAdsorbPoint = function getAdsorbPoint(position, features, options, scene) {
  var pointAdsorbPixel = options.pointAdsorbPixel;
  var points = [];
  // 获取 features 中所有的点
  if (features.length) points = features.map(function (feature) {
    var _feature$properties;
    var _ref = (_feature$properties = feature.properties) !== null && _feature$properties !== void 0 ? _feature$properties : {},
      _ref$nodes = _ref.nodes,
      nodes = _ref$nodes === void 0 ? [] : _ref$nodes,
      _ref$isActive = _ref.isActive,
      isActive = _ref$isActive === void 0 ? false : _ref$isActive;
    return isActive ? nodes.filter(function (node) {
      return !(0, _lodash.isEqual)(node.geometry.coordinates, position);
    }) : nodes;
  }).flat().filter(function (feature) {
    return feature;
  });
  if (!points.length) {
    points = (0, _turf.coordAll)((0, _turf.featureCollection)(features)).map(function (position) {
      return (0, _turf.point)(position);
    });
  }
  // 通过计算当前鼠标向外扩展 pixel 的 bbox 快速筛选 points
  points = points.filter(function (point) {
    var pointExpandBBox = getPixelExpandBBox(point, scene, pointAdsorbPixel);
    return isPositionInBBox(position, pointExpandBBox);
  });
  if (!points.length) {
    return null;
  }
  var _position = _slicedToArray(position, 2),
    lng = _position[0],
    lat = _position[1];
  var _scene$lngLatToPixel = scene.lngLatToPixel([lng, lat]),
    mouseX = _scene$lngLatToPixel.x,
    mouseY = _scene$lngLatToPixel.y;
  var squareDistanceList = points.map(function (point) {
    var _point$geometry$coord = _slicedToArray(point.geometry.coordinates, 2),
      lng = _point$geometry$coord[0],
      lat = _point$geometry$coord[1];
    var _scene$lngLatToPixel2 = scene.lngLatToPixel([lng, lat]),
      x = _scene$lngLatToPixel2.x,
      y = _scene$lngLatToPixel2.y;
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2);
  });
  var minIndex = (0, _common.findMinIndex)(squareDistanceList);
  var minDistance = Math.pow(squareDistanceList[minIndex], 0.5);
  if (minDistance <= pointAdsorbPixel) {
    return points[minIndex].geometry.coordinates;
  } else {
    return null;
  }
};
var getAdsorbLine = function getAdsorbLine(position, features, options, scene) {
  var lines = [];
  lines = features.map(function (feature) {
    var _feature$properties2, _feature$properties3;
    var line = (_feature$properties2 = feature.properties) === null || _feature$properties2 === void 0 ? void 0 : _feature$properties2.line;
    if (((_feature$properties3 = feature.properties) === null || _feature$properties3 === void 0 ? void 0 : _feature$properties3.isActive) && line) {
      var nodes = line.properties.nodes;
      var positionsList = (0, _common.splitByPosition)(nodes.map(function (node) {
        return node.geometry.coordinates;
      }), position).filter(function (positions) {
        return positions.length > 1;
      });
      return positionsList.map(function (positions) {
        return (0, _turf.lineString)(positions);
      });
    }
    return [line];
  }).flat().filter(function (feature) {
    return feature;
  });
  if (!lines.length) {
    features.forEach(function (feature) {
      var featureType = (0, _turf.getType)(feature);
      if (/linestring/i.test(featureType)) {
        lines.push(feature);
      }
      if (/polygon/i.test(featureType)) {
        var _lines, _result$features;
        var result = (0, _turf.polygonToLine)(feature);
        // @ts-ignore
        return (_lines = lines).push.apply(_lines, _toConsumableArray((_result$features = result === null || result === void 0 ? void 0 : result.features) !== null && _result$features !== void 0 ? _result$features : [result]));
      }
    });
  }
  var lineAdsorbPixel = options.lineAdsorbPixel;
  var _position2 = _slicedToArray(position, 2),
    lng = _position2[0],
    lat = _position2[1];
  var _scene$lngLatToPixel3 = scene.lngLatToPixel([lng, lat]),
    mouseX = _scene$lngLatToPixel3.x,
    mouseY = _scene$lngLatToPixel3.y;
  var nearestPointList = lines.filter(function (line) {
    return (0, _turf.coordAll)(line).length > 1;
  }).map(function (line) {
    return (0, _turf.nearestPointOnLine)(line, position);
  });
  if (!nearestPointList.length) {
    return null;
  }
  var squareDistanceList = nearestPointList.map(function (point) {
    var _point$geometry$coord2 = _slicedToArray(point.geometry.coordinates, 2),
      lng = _point$geometry$coord2[0],
      lat = _point$geometry$coord2[1];
    var _scene$lngLatToPixel4 = scene.lngLatToPixel([lng, lat]),
      x = _scene$lngLatToPixel4.x,
      y = _scene$lngLatToPixel4.y;
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2);
  });
  var minIndex = (0, _common.findMinIndex)(squareDistanceList);
  var minDistance = Math.pow(squareDistanceList[minIndex], 0.5);
  if (minDistance <= lineAdsorbPixel) {
    return nearestPointList[minIndex].geometry.coordinates;
  } else {
    return null;
  }
};
/**
 * 返回 feature 的 bbox 向外扩展 expandPixel 像素后的新 bbox
 * @param feature
 * @param scene
 * @param expandPixel
 * @returns
 */
var getPixelExpandBBox = exports.getPixelExpandBBox = function getPixelExpandBBox(feature, scene, expandPixel) {
  var _feature$bbox;
  var bbox = (_feature$bbox = feature.bbox) !== null && _feature$bbox !== void 0 ? _feature$bbox : (0, _feature.injectFeaturesBBox)([feature])[0].bbox;
  var _bbox = _slicedToArray(bbox, 4),
    minLng = _bbox[0],
    minLat = _bbox[1],
    maxLng = _bbox[2],
    maxLat = _bbox[3];
  var _scene$lngLatToContai = scene.lngLatToContainer([minLng, minLat]),
    minX = _scene$lngLatToContai.x,
    minY = _scene$lngLatToContai.y;
  var _scene$lngLatToContai2 = scene.lngLatToContainer([maxLng, maxLat]),
    maxX = _scene$lngLatToContai2.x,
    maxY = _scene$lngLatToContai2.y;
  var _scene$containerToLng = scene.containerToLngLat([minX - expandPixel, minY + expandPixel]),
    lng1 = _scene$containerToLng.lng,
    lat1 = _scene$containerToLng.lat;
  var _scene$containerToLng2 = scene.containerToLngLat([maxX + expandPixel, maxY - expandPixel]),
    lng2 = _scene$containerToLng2.lng,
    lat2 = _scene$containerToLng2.lat;
  return [Math.min(lng1, lng2), Math.min(lat1, lat2), Math.max(lng1, lng2), Math.max(lat1, lat2)];
};
/**
 * 判断 position 是否在 bbox 内
 * @param position
 * @param bbox
 * @returns
 */
var isPositionInBBox = exports.isPositionInBBox = function isPositionInBBox(position, bbox) {
  var _bbox2 = _slicedToArray(bbox, 4),
    minLng = _bbox2[0],
    minLat = _bbox2[1],
    maxLng = _bbox2[2],
    maxLat = _bbox2[3];
  var _position3 = _slicedToArray(position, 2),
    lng = _position3[0],
    lat = _position3[1];
  return lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
};
/**
 * 获取当前数据对应的吸附点、线数组
 * @param adsorbDataConfig
 * @param draw
 * @param position
 */
var getAdsorbPosition = exports.getAdsorbPosition = function getAdsorbPosition(_ref2) {
  var adsorbOptions = _ref2.adsorbOptions,
    draw = _ref2.draw,
    position = _ref2.position,
    scene = _ref2.scene;
  var adsorbData = adsorbOptions.data,
    pointAdsorbPixel = adsorbOptions.pointAdsorbPixel,
    lineAdsorbPixel = adsorbOptions.lineAdsorbPixel;
  var features = [];
  if (adsorbData === 'allDrawData') {
    features = _mode.BaseMode.instances.map(function (draw) {
      return draw.getData(true);
    }).flat();
  } else if (adsorbData === 'drawData') {
    features = draw.getData(true);
  } else if (adsorbData instanceof Function) {
    features = adsorbData(position);
  } else {
    features = adsorbData;
  }
  // 通过 bbox 筛选出在吸附范围的 features
  features = features.filter(function (feature) {
    var _feature$properties4;
    if ((_feature$properties4 = feature.properties) === null || _feature$properties4 === void 0 ? void 0 : _feature$properties4.isActive) {
      return true;
    }
    var pointExpandBBox = getPixelExpandBBox(feature, scene, pointAdsorbPixel);
    if (isPositionInBBox(position, pointExpandBBox)) {
      return true;
    }
    var lineExpandBBox = getPixelExpandBBox(feature, scene, lineAdsorbPixel);
    if (isPositionInBBox(position, lineExpandBBox)) {
      return true;
    }
    return false;
  });
  if (adsorbOptions.pointAdsorbPixel > 0) {
    // 获取 features 中距离最近的点
    var adsorbPointPosition = getAdsorbPoint(position, features, adsorbOptions, scene);
    if (adsorbPointPosition) {
      return adsorbPointPosition;
    }
  }
  if (adsorbOptions.lineAdsorbPixel > 0) {
    var adsorbLinePosition = getAdsorbLine(position, features, adsorbOptions, scene);
    if (adsorbLinePosition) {
      return adsorbLinePosition;
    }
  }
  return position;
};