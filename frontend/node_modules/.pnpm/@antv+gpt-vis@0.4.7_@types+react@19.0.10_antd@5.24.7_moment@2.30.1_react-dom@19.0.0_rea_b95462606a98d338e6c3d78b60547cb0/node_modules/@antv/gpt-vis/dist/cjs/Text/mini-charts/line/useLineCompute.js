var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/Text/mini-charts/line/useLineCompute.ts
var useLineCompute_exports = {};
__export(useLineCompute_exports, {
  useLineCompute: () => useLineCompute
});
module.exports = __toCommonJS(useLineCompute_exports);
var import_react = require("react");
var import_theme = require("../../theme");
var import_scaleLinear = require("./scaleLinear");
var SCALE_ADJUST = 2;
var Line = class {
  constructor(size, data) {
    this.data = [];
    this.size = import_theme.TEXT_THEME.fontSizeBase;
    this.height = this.size;
    this.width = this.getWidth();
    this.points = [];
    this.size = size;
    if (data) {
      this.data = data;
      this.compute();
    }
  }
  getWidth() {
    var _a;
    return Math.max(this.size * 2, ((_a = this.data) == null ? void 0 : _a.length) * 2);
  }
  compute() {
    var _a;
    if (!this.data)
      return;
    this.height = this.size;
    this.width = this.getWidth();
    this.xScale = (0, import_scaleLinear.scaleLinear)([0, this.width], [0, ((_a = this.data) == null ? void 0 : _a.length) - 1]);
    const [min, max] = [Math.min(...this.data), Math.max(...this.data)];
    this.yScale = (0, import_scaleLinear.scaleLinear)([SCALE_ADJUST, this.height - SCALE_ADJUST], [min, max]);
    this.points = this.data.map((item, index) => [
      this.xScale(index),
      this.height - this.yScale(item)
    ]);
  }
  getLinePath() {
    var _a;
    if (!((_a = this.data) == null ? void 0 : _a.length) || !this.xScale || !this.yScale)
      return null;
    const path = this.points.reduce((prev, [x, y], index) => {
      if (index === 0)
        return `M${x} ${y}`;
      return `${prev} L ${x} ${y}`;
    }, "");
    return path;
  }
  getPolygonPath() {
    var _a;
    if (!((_a = this.data) == null ? void 0 : _a.length) || !this.xScale || !this.yScale)
      return null;
    const polygonPoints = [...this.points];
    const last = this.points[this.points.length - 1];
    polygonPoints.push([last[0], this.height]);
    polygonPoints.push([0, this.height]);
    const startPoint = this.points[0];
    polygonPoints.push(startPoint);
    const path = polygonPoints.reduce((prev, [x, y]) => `${prev} ${x},${y}`, "");
    return path;
  }
  getContainer() {
    return [this.width, this.height];
  }
};
var useLineCompute = (size, data) => {
  const [line, setLine] = (0, import_react.useState)(new Line(size, data));
  (0, import_react.useEffect)(() => {
    setLine(new Line(size, data));
  }, [size, data]);
  return {
    width: line.getContainer()[0],
    height: line.getContainer()[1],
    linePath: line.getLinePath(),
    polygonPath: line.getPolygonPath()
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useLineCompute
});
