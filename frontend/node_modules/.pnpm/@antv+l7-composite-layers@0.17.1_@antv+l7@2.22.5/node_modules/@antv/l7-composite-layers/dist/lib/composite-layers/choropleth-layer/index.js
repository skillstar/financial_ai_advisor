"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoroplethLayer = void 0;
const tslib_1 = require("tslib");
const util_1 = require("@antv/util");
const line_layer_1 = require("../../core-layers/line-layer");
const polygon_layer_1 = require("../../core-layers/polygon-layer");
const text_layer_1 = require("../../core-layers/text-layer");
const composite_layer_1 = require("../../core/composite-layer");
const constants_1 = require("../common/constants");
const multi_select_1 = require("../common/multi-select");
const adaptor_1 = require("./adaptor");
const constants_2 = require("./constants");
const helper_1 = require("./helper");
class ChoroplethLayer extends composite_layer_1.CompositeLayer {
    /**
     * 主图层
     */
    get layer() {
        return this.fillLayer;
    }
    /**
     * 填充面图层
     */
    get fillLayer() {
        return this.subLayers.getLayer('fillLayer');
    }
    /**
     * 描边图层
     */
    get strokeLayer() {
        return this.subLayers.getLayer('strokeLayer');
    }
    /**
     * 高亮描边图层
     */
    get highlightStrokeLayer() {
        return this.subLayers.getLayer('highlightStrokeLayer');
    }
    /**
     * 选中填充面图层
     */
    get selectFillLayer() {
        return this.subLayers.getLayer('selectFillLayer');
    }
    /**
     * 选中描边图层
     */
    get selectStrokeLayer() {
        return this.subLayers.getLayer('selectStrokeLayer');
    }
    /**
     * 标注文本图层
     */
    get labelLayer() {
        return this.subLayers.getLayer('labelLayer');
    }
    constructor(options) {
        super(options);
        /**
         * 复合图层类型
         */
        this.type = composite_layer_1.CompositeLayer.LayerType.ChoroplethLayer;
        /**
         * 选中数据
         */
        this.selectData = [];
        /**
         * 图层交互状态配置
         */
        this.layerState = constants_2.DEFAULT_STATE;
        /**
         * 图层高亮回调
         */
        this.onHighlighHandle = (event) => {
            const { feature, featureId } = event;
            this.setHighlightLayerSource(feature, featureId);
        };
        /**
         * 图层取消高亮回调
         */
        this.onUnhighlighHandle = () => {
            this.setHighlightLayerSource();
        };
        /**
         * 图层选中回调
         */
        this.onSelectHandle = (event) => {
            const { feature, featureId } = event;
            this.handleSelectData(featureId, feature);
        };
        this.initSubLayersEvent();
    }
    /**
     * 获取默认配置
     */
    getDefaultOptions() {
        return ChoroplethLayer.DefaultOptions;
    }
    /**
     * 创建子图层
     */
    createSubLayers() {
        const source = this.source;
        this.layerState = (0, adaptor_1.getDefaultState)(this.options.state);
        // 映射填充面图层
        const fillLayer = new polygon_layer_1.PolygonLayer(Object.assign(Object.assign({}, this.getFillLayerOptions()), { id: 'fillLayer', shape: 'fill', source, interaction: true }));
        // 描边图层
        const strokeLayer = new line_layer_1.LineLayer(Object.assign(Object.assign({}, this.getStrokeLayerOptions()), { id: 'strokeLayer', shape: 'line', source }));
        // 高亮描边图层
        const highlightStrokeLayer = new line_layer_1.LineLayer(Object.assign(Object.assign({}, this.getHighlightStrokeLayerOptions()), { id: 'highlightStrokeLayer' }));
        // 选中填充图层
        const selectFillLayer = new polygon_layer_1.PolygonLayer(Object.assign(Object.assign({}, this.getSelectFillLayerOptions()), { id: 'selectFillLayer' }));
        // 选中描边图层
        const selectStrokeLayer = new line_layer_1.LineLayer(Object.assign(Object.assign({}, this.getSelectStrokeLayerOptions()), { id: 'selectStrokeLayer' }));
        // 标注图层
        const labelLayer = new text_layer_1.TextLayer(Object.assign(Object.assign({}, (0, helper_1.getLabelLayerOptions)(this.options, source)), { id: 'labelLayer' }));
        const subLayers = [fillLayer, strokeLayer, highlightStrokeLayer, selectFillLayer, selectStrokeLayer, labelLayer];
        return subLayers;
    }
    /**
     * 获取填充图层配置项
     */
    getFillLayerOptions() {
        // omit source 目前是图层共享 source，避免更新时透传 source 数据
        const _a = (0, util_1.omit)(this.options, ['source']), { visible, minZoom, maxZoom, zIndex = 0, fillColor, opacity } = _a, baseConfig = tslib_1.__rest(_a, ["visible", "minZoom", "maxZoom", "zIndex", "fillColor", "opacity"]);
        const defaultState = this.layerState;
        const fillState = {
            active: defaultState.active.fillColor === false ? false : { color: defaultState.active.fillColor },
            select: false,
        };
        const fillStyle = { opacity: opacity };
        const options = Object.assign(Object.assign({}, baseConfig), { visible,
            minZoom,
            maxZoom,
            zIndex, color: fillColor, state: fillState, style: fillStyle });
        return options;
    }
    getStrokeLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, opacity, strokeColor, lineWidth, lineOpacity, lineDash, lineType, filter, } = this.options;
        const strokeStyle = {
            opacity: (0, util_1.isUndefined)(lineOpacity) ? opacity : lineOpacity,
            dashArray: lineDash,
            lineType: lineType,
        };
        const options = {
            visible: visible && Boolean(lineWidth) && Boolean(strokeColor),
            zIndex,
            minZoom,
            maxZoom,
            size: lineWidth,
            color: strokeColor,
            style: strokeStyle,
            filter,
        };
        return options;
    }
    getHighlightStrokeLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, lineWidth } = this.options;
        const defaultState = this.layerState;
        const color = defaultState.active.strokeColor || undefined;
        const size = defaultState.active.lineWidth || lineWidth;
        const options = {
            visible: visible && Boolean(color),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: constants_1.EMPTY_GEOJSON_SOURCE,
            size: size,
            color: color,
            style: { opacity: defaultState.active.lineOpacity },
        };
        return options;
    }
    getSelectFillLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, opacity } = this.options;
        const defaultState = this.layerState;
        const color = defaultState.select.fillColor || undefined;
        const fillStyle = { opacity: opacity };
        const option = {
            visible: visible && Boolean(color),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: constants_1.EMPTY_GEOJSON_SOURCE,
            color,
            style: fillStyle,
            state: { select: false, active: false },
        };
        return option;
    }
    getSelectStrokeLayerOptions() {
        const { visible, minZoom, maxZoom, zIndex = 0, lineWidth } = this.options;
        const defaultState = this.layerState;
        const color = defaultState.select.strokeColor || undefined;
        const size = defaultState.select.lineWidth || lineWidth;
        const option = {
            visible: visible && Boolean(color),
            zIndex: zIndex + 0.1,
            minZoom,
            maxZoom,
            source: constants_1.EMPTY_GEOJSON_SOURCE,
            size,
            color,
            style: { opacity: defaultState.select.lineOpacity },
        };
        return option;
    }
    /**
     * 设置子图层数据
     */
    setSubLayersSource(source) {
        var _a;
        if (this.isSourceInstance(source)) {
            this.source = source;
            this.fillLayer.setSource(source);
            this.strokeLayer.setSource(source);
            this.labelLayer.setSource(source);
        }
        else {
            const { data } = source, option = tslib_1.__rest(source, ["data"]);
            this.source.setData(data, option);
            // 自定义标注图层 position 时，source 不是共享的 Source 实例
            if ((0, helper_1.isLabelPosition)((_a = this.options.label) === null || _a === void 0 ? void 0 : _a.position)) {
                const labelSource = (0, helper_1.parserLabeSourceData)(this.source, this.options.label);
                this.labelLayer.changeData(labelSource);
            }
        }
        this.highlightStrokeLayer.changeData(constants_1.EMPTY_GEOJSON_SOURCE);
        this.selectFillLayer.changeData(constants_1.EMPTY_GEOJSON_SOURCE);
        this.selectStrokeLayer.changeData(constants_1.EMPTY_GEOJSON_SOURCE);
    }
    /**
     * 设置高亮描边子图层数据
     */
    setHighlightLayerSource(feature, featureId = -999) {
        if (this.highlightData === featureId) {
            return;
        }
        const features = feature ? [feature] : [];
        const parser = this.source.parser;
        const data = parser.type === 'geojson' ? { type: 'FeatureCollection', features } : features;
        this.highlightStrokeLayer.changeData({ data, parser });
        this.highlightData = featureId;
    }
    /**
     * 设置选中描边与填充子图层数据
     */
    setSelectLayerSource(selectData = []) {
        if (this.selectData.length === selectData.length &&
            (0, util_1.isEqual)(this.selectData.map(({ featureId }) => featureId), selectData.map(({ featureId }) => featureId))) {
            return;
        }
        const features = selectData.map(({ feature }) => feature);
        const parser = this.source.parser;
        const data = parser.type === 'geojson' ? { type: 'FeatureCollection', features } : features;
        this.selectFillLayer.changeData({ data, parser });
        this.selectStrokeLayer.changeData({ data, parser });
        this.selectData = selectData;
    }
    /**
     * 初始化子图层事件
     */
    initSubLayersEvent() {
        // 初始化主图层交互事件
        this.fillLayer.off('mousemove', this.onHighlighHandle);
        this.fillLayer.off('mouseout', this.onHighlighHandle);
        this.fillLayer.off('click', this.onSelectHandle);
        this.selectData = [];
        this.highlightData = null;
        if (!this.options.state)
            return;
        // active
        if (this.options.state.active) {
            this.fillLayer.on('mousemove', this.onHighlighHandle);
            this.fillLayer.on('mouseout', this.onUnhighlighHandle);
        }
        // select
        if (this.options.state.select) {
            this.fillLayer.on('click', this.onSelectHandle);
        }
    }
    /**
     * 处理选择数据私有方法
     */
    handleSelectData(featureId, feature, isSelfMultiSelect) {
        const { enabledMultiSelect, triggerMultiSelectKey } = this.options;
        const isMultiSelect = (0, multi_select_1.isGestureMultiSelect)(enabledMultiSelect, triggerMultiSelectKey) || isSelfMultiSelect;
        let selectData = (0, util_1.clone)(this.selectData);
        const index = selectData.findIndex((item) => item.featureId === featureId);
        if (index === -1) {
            if (isMultiSelect) {
                selectData.push({ feature, featureId });
            }
            else {
                selectData = [{ feature, featureId }];
            }
            this.emit('select', feature, (0, util_1.clone)(selectData));
        }
        else {
            const unselectFeature = selectData[index];
            if (isMultiSelect) {
                selectData.splice(index, 1);
            }
            else {
                selectData = [];
            }
            this.emit('unselect', unselectFeature, (0, util_1.clone)(selectData));
        }
        this.setSelectLayerSource(selectData);
    }
    /**
     * 更新
     */
    update(options) {
        super.update(options);
        this.initSubLayersEvent();
    }
    /**
     * 更新: 更新配置
     */
    updateOption(options) {
        super.updateOption(options);
        this.layerState = (0, adaptor_1.getDefaultState)(this.options.state);
    }
    /**
     * 更新子图层
     */
    updateSubLayers(options) {
        // 映射填充面图层
        this.fillLayer.update(this.getFillLayerOptions(), false);
        // 描边图层
        this.strokeLayer.update(this.getStrokeLayerOptions(), false);
        // 高亮图层
        this.highlightStrokeLayer.update(this.getHighlightStrokeLayerOptions(), false);
        // 选中填充图层
        this.selectFillLayer.update(this.getSelectFillLayerOptions(), false);
        // 选中描边图层
        this.selectStrokeLayer.update(this.getSelectStrokeLayerOptions(), false);
        // 标注图层
        this.labelLayer.update((0, helper_1.getLabelLayerOptions)(this.options, this.source), false);
        // 重置高亮/选中状态
        if (this.options.visible) {
            if (!(0, util_1.isUndefined)(options.state) && !(0, util_1.isEqual)(this.lastOptions.state, this.options.state)) {
                this.updateHighlightSubLayers();
            }
            if (this.layerState.active.strokeColor) {
                this.setHighlightLayerSource();
            }
            if (this.layerState.select.fillColor || this.layerState.select.strokeColor) {
                this.setSelectLayerSource();
            }
        }
    }
    /**
     * 更新高亮及选中子图层
     */
    updateHighlightSubLayers() {
        const defaultState = this.layerState;
        const lasetDefaultState = (0, adaptor_1.getDefaultState)(this.lastOptions.state);
        if (lasetDefaultState.active.strokeColor !== defaultState.active.strokeColor) {
            defaultState.active.strokeColor ? this.highlightStrokeLayer.show() : this.highlightStrokeLayer.hide();
        }
        if (lasetDefaultState.select.fillColor !== defaultState.select.fillColor) {
            defaultState.select.fillColor ? this.selectFillLayer.show() : this.selectFillLayer.hide();
        }
        if (lasetDefaultState.select.strokeColor !== defaultState.select.strokeColor) {
            defaultState.select.strokeColor ? this.selectStrokeLayer.show() : this.selectStrokeLayer.hide();
        }
    }
    /**
     * 设置图层 zIndex
     */
    setIndex(zIndex) {
        this.fillLayer.setIndex(zIndex);
        this.strokeLayer.setIndex(zIndex);
        this.highlightStrokeLayer.setIndex(zIndex + 0.1);
        this.selectFillLayer.setIndex(zIndex + 0.1);
        this.selectStrokeLayer.setIndex(zIndex + 0.1);
        this.labelLayer.setIndex(zIndex + 0.1);
    }
    /**
     * 设置图层高亮状态
     */
    setActive(field, value) {
        const source = this.fillLayer.source;
        const featureId = source.getFeatureId(field, value);
        if ((0, util_1.isUndefined)(featureId)) {
            console.warn(`Feature non-existent by field: ${field},value: ${value}`);
            return;
        }
        if (this.layerState.active.fillColor) {
            this.fillLayer.layer.setActive(featureId);
        }
        if (this.layerState.active.strokeColor) {
            const feature = source.getFeatureById(featureId);
            this.setHighlightLayerSource(feature, featureId);
        }
    }
    /**
     * 设置图层选中状态
     */
    setSelect(field, value) {
        const source = this.fillLayer.source;
        const featureId = source.getFeatureId(field, value);
        if ((0, util_1.isUndefined)(featureId)) {
            console.warn(`Feature non-existent by field: ${field},value: ${value}`);
            return;
        }
        if (this.layerState.select.strokeColor === false && this.layerState.select.fillColor === false) {
            return;
        }
        const feature = source.getFeatureById(featureId);
        const { enabledMultiSelect } = this.options;
        this.handleSelectData(featureId, feature, enabledMultiSelect);
        // TODO: L7 method pickFeature(id|{x,y})
    }
    /**
     * 图层框选数据
     */
    boxSelect(bounds, callback) {
        this.fillLayer.boxSelect(bounds, callback);
    }
}
exports.ChoroplethLayer = ChoroplethLayer;
/**
 * 默认配置项
 */
ChoroplethLayer.DefaultOptions = constants_2.DEFAULT_OPTIONS;
//# sourceMappingURL=index.js.map