function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { fromPairs, toPairs } from 'lodash-es';
import { useCallback, useMemo } from 'react';
import { useDraw } from "../use-draw";
export var useDrawGroup = function useDrawGroup(_ref, commonOptions) {
  var pointConfig = _ref.point,
    lineConfig = _ref.line,
    polygonConfig = _ref.polygon,
    rectConfig = _ref.rect,
    circleConfig = _ref.circle;
  var hasPointConfig = !!pointConfig;
  var hasLineConfig = !!lineConfig;
  var hasPolygonConfig = !!polygonConfig;
  var hasRectConfig = !!rectConfig;
  var hasCircleConfig = !!circleConfig;
  var getDrawOptions = useCallback(function (options) {
    return _objectSpread(_objectSpread({}, commonOptions), options instanceof Object ? options : {});
  }, [commonOptions]);
  var pointDrawHook = useDraw({
    type: 'point',
    options: getDrawOptions(pointConfig)
  });
  var lineDrawHook = useDraw({
    type: 'line',
    options: getDrawOptions(lineConfig)
  });
  var polygonDrawHook = useDraw({
    type: 'polygon',
    options: getDrawOptions(polygonConfig)
  });
  var rectDrawHook = useDraw({
    type: 'rect',
    options: getDrawOptions(rectConfig)
  });
  var circleDrawHook = useDraw({
    type: 'circle',
    options: getDrawOptions(circleConfig)
  });
  var drawInfoMap = useMemo(function () {
    return fromPairs(toPairs({
      point: hasPointConfig ? pointDrawHook : undefined,
      line: hasLineConfig ? lineDrawHook : undefined,
      polygon: hasPolygonConfig ? polygonDrawHook : undefined,
      rect: hasRectConfig ? rectDrawHook : undefined,
      circle: hasCircleConfig ? circleDrawHook : undefined
    }).filter(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
        hook = _ref3[1];
      return !!hook;
    }));
  }, [pointDrawHook, lineDrawHook, polygonDrawHook, rectDrawHook, circleDrawHook, hasPointConfig, hasLineConfig, hasPolygonConfig, hasRectConfig, hasCircleConfig]);
  var drawMap = useMemo(function () {
    return fromPairs(toPairs(drawInfoMap).map(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        type = _ref5[0],
        hook = _ref5[1];
      return [type, hook.draw];
    }));
  }, [drawInfoMap]);
  var drawGroupData = useMemo(function () {
    return fromPairs(toPairs(drawInfoMap).map(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
        type = _ref7[0],
        hook = _ref7[1];
      return [type, hook.drawData];
    }));
  }, [drawInfoMap]);
  var setDrawGroupData = useCallback(function (newData) {
    Object.entries(newData).forEach(function (_ref8) {
      var _drawInfoMap$type;
      var _ref9 = _slicedToArray(_ref8, 2),
        type = _ref9[0],
        newDrawData = _ref9[1];
      (_drawInfoMap$type = drawInfoMap[type]) === null || _drawInfoMap$type === void 0 || _drawInfoMap$type.setDrawData(newDrawData);
    });
  }, [drawInfoMap]);
  var activeDrawInfo = useMemo(function () {
    return Object.values(drawInfoMap).find(function (hook) {
      return hook.isEnable;
    });
  }, [drawInfoMap]);
  var activeDraw = useMemo(function () {
    var _activeDrawInfo$draw;
    return (_activeDrawInfo$draw = activeDrawInfo === null || activeDrawInfo === void 0 ? void 0 : activeDrawInfo.draw) !== null && _activeDrawInfo$draw !== void 0 ? _activeDrawInfo$draw : null;
  }, [activeDrawInfo]);
  var setActiveDraw = useCallback(function (target) {
    Object.values(drawInfoMap).forEach(function (hook) {
      var _drawInfoMap$target$d, _drawInfoMap$target;
      if (!hook) {
        return;
      }
      var targetDraw = typeof target === 'string' ? (_drawInfoMap$target$d = (_drawInfoMap$target = drawInfoMap[target]) === null || _drawInfoMap$target === void 0 ? void 0 : _drawInfoMap$target.draw) !== null && _drawInfoMap$target$d !== void 0 ? _drawInfoMap$target$d : null : target;
      if (!targetDraw) {
        hook.disable();
        return;
      }
      var enabled = hook.isEnable;
      if (targetDraw === hook.draw) {
        if (!enabled) {
          hook.enable();
        }
      } else if (enabled) {
        hook.disable();
      }
    });
  }, [drawInfoMap]);
  return {
    drawMap: drawMap,
    drawGroupData: drawGroupData,
    setDrawGroupData: setDrawGroupData,
    activeDraw: activeDraw,
    activeDrawInfo: activeDrawInfo,
    setActiveDraw: setActiveDraw
  };
};