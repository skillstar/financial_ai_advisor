function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import { LayerPopup as L7LayerPopup } from '@antv/l7';
import { omitBy } from 'lodash-es';
import React, { useEffect, useMemo, useState } from 'react';
import { getStyleText } from "../../utils";
import { useL7ComponentEvent, useL7ComponentUpdate } from "../Control/hooks";
import { useLayerList, useScene } from "../LarkMap/hooks";
import { getElementTypePortal } from "./utils";
export var LayerPopup = function LayerPopup(_ref) {
  var style = _ref.style,
    closeButton = _ref.closeButton,
    closeButtonOffsets = _ref.closeButtonOffsets,
    closeOnClick = _ref.closeOnClick,
    closeOnEsc = _ref.closeOnEsc,
    maxWidth = _ref.maxWidth,
    anchor = _ref.anchor,
    offsets = _ref.offsets,
    stopPropagation = _ref.stopPropagation,
    autoPan = _ref.autoPan,
    autoClose = _ref.autoClose,
    className = _ref.className,
    lngLat = _ref.lngLat,
    items = _ref.items,
    trigger = _ref.trigger,
    onOpen = _ref.onOpen,
    onClose = _ref.onClose,
    onShow = _ref.onShow,
    onHide = _ref.onHide;
  var scene = useScene();
  var _useState = useState(),
    _useState2 = _slicedToArray(_useState, 2),
    popup = _useState2[0],
    setPopup = _useState2[1];
  var styleText = useMemo(function () {
    return getStyleText(style);
  }, [style]);
  var fullLayerList = useLayerList();
  var layerPopupItems = useMemo(function () {
    var result = [];
    items.forEach(function (item) {
      var originLayer;
      // 若 layer 为字符串格式，统一从 LarkMap 的 LayerManger 中获取 layer 实例
      if (typeof item.layer === 'string') {
        var targetLayer = fullLayerList.find(function (layer) {
          return layer.id === item.layer;
        });
        if (targetLayer) {
          originLayer = targetLayer;
        } else {
          // 在传 Layer id 的情况下，如果未找到目标图层实例则直接跳过当前配置项
          return;
        }
      } else {
        originLayer = item.layer;
      }
      var layers = [];
      if (originLayer.isComposite) {
        // 若 originLayer 为交互图层，
        // @ts-ignore
        layers.push.apply(layers, _toConsumableArray(originLayer.getInteractionSubLayers()));
      } else {
        // @ts-ignore
        layers.push(originLayer);
      }
      layers.forEach(function (layer) {
        var _item$fields;
        var newItem = {
          layer: layer
        };
        if (item.title) {
          newItem.title = getElementTypePortal(item.title, 'div');
        }
        if (item.customContent) {
          newItem.customContent = getElementTypePortal(item.customContent, 'div');
        }
        if ((_item$fields = item.fields) !== null && _item$fields !== void 0 && _item$fields.length) {
          newItem.fields = item.fields.map(function (field) {
            if (typeof field === 'string') {
              return field;
            } else {
              var newField = {
                field: field.field,
                getValue: field.getValue
              };
              if (field.formatField) {
                newField.formatField = getElementTypePortal(field.formatField, 'span');
              }
              if (field.formatValue) {
                newField.formatValue = getElementTypePortal(field.formatValue, 'span');
              }
              return newField;
            }
          });
        }
        result.push(newItem);
      });
    });
    return result;
  }, [fullLayerList, items]);
  var layerPopupOptions = useMemo(function () {
    return {
      style: styleText,
      closeButton: closeButton,
      closeButtonOffsets: closeButtonOffsets,
      closeOnClick: closeOnClick,
      closeOnEsc: closeOnEsc,
      maxWidth: maxWidth,
      anchor: anchor,
      offsets: offsets,
      stopPropagation: stopPropagation,
      autoPan: autoPan,
      autoClose: autoClose,
      followCursor: trigger === 'hover',
      className: className,
      lngLat: lngLat,
      items: layerPopupItems,
      trigger: trigger
    };
  }, [styleText, closeButton,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(closeButtonOffsets), closeOnClick, closeOnEsc, maxWidth, anchor,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(offsets), stopPropagation, autoPan, autoClose, className, trigger,
  // eslint-disable-next-line react-hooks/exhaustive-deps
  JSON.stringify(lngLat), layerPopupItems]);
  useEffect(function () {
    var newPopup = new L7LayerPopup(omitBy(layerPopupOptions, function (value) {
      return value === undefined;
    }));
    setPopup(newPopup);
    scene.addPopup(newPopup);
    return function () {
      scene.removePopup(newPopup);
      setPopup(undefined);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useL7ComponentUpdate(popup, layerPopupOptions);
  useL7ComponentEvent(popup, {
    open: onOpen,
    close: onClose,
    show: onShow,
    hide: onHide
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null);
};